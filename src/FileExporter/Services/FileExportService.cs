using FileExporter.Models;
using System.Globalization;
using System.Text;

namespace FileExporter.Services
{
    /// <summary>
    /// Service for exporting 3D data to various file formats
    /// </summary>
    public class FileExportService
    {
        /// <summary>
        /// Export point cloud to PLY format
        /// </summary>
        public async Task ExportToPlyAsync(ColoredPoint3D[] points, string filePath, bool includeBinary = false)
        {
            var header = new StringBuilder();
            header.AppendLine("ply");
            header.AppendLine(includeBinary ? "format binary_little_endian 1.0" : "format ascii 1.0");
            header.AppendLine($"element vertex {points.Length}");
            header.AppendLine("property float x");
            header.AppendLine("property float y");
            header.AppendLine("property float z");
            header.AppendLine("property uchar red");
            header.AppendLine("property uchar green");
            header.AppendLine("property uchar blue");
            
            if (points.Length > 0 && points[0].Normal != default)
            {
                header.AppendLine("property float nx");
                header.AppendLine("property float ny");
                header.AppendLine("property float nz");
            }
            
            header.AppendLine("end_header");

            if (includeBinary)
            {
                await ExportPlyBinaryAsync(points, filePath, header.ToString());
            }
            else
            {
                await ExportPlyAsciiAsync(points, filePath, header.ToString());
            }
        }

        /// <summary>
        /// Export mesh to STL format
        /// </summary>
        public async Task ExportToStlAsync(Mesh mesh, string filePath, bool includeBinary = true)
        {
            if (includeBinary)
            {
                await ExportStlBinaryAsync(mesh, filePath);
            }
            else
            {
                await ExportStlAsciiAsync(mesh, filePath);
            }
        }

        /// <summary>
        /// Export mesh to OBJ format
        /// </summary>
        public async Task ExportToObjAsync(Mesh mesh, string filePath)
        {
            var content = new StringBuilder();
            
            // Header
            content.AppendLine("# OBJ file generated by Azure Kinect 3D Scanner");
            content.AppendLine($"# Generated on {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            content.AppendLine();

            // Material file reference
            var mtlFileName = Path.ChangeExtension(Path.GetFileName(filePath), ".mtl");
            content.AppendLine($"mtllib {mtlFileName}");
            content.AppendLine("usemtl material0");
            content.AppendLine();

            // Vertices
            foreach (var vertex in mesh.Vertices)
            {
                content.AppendLine($"v {vertex.Position.X:F6} {vertex.Position.Y:F6} {vertex.Position.Z:F6}");
            }

            // Vertex normals
            foreach (var vertex in mesh.Vertices)
            {
                content.AppendLine($"vn {vertex.Normal.X:F6} {vertex.Normal.Y:F6} {vertex.Normal.Z:F6}");
            }

            // Vertex textures (colors as UV coordinates)
            foreach (var vertex in mesh.Vertices)
            {
                content.AppendLine($"vt {vertex.Color.X:F6} {vertex.Color.Y:F6}");
            }

            // Faces (OBJ uses 1-based indexing)
            for (int i = 0; i < mesh.Faces.Length; i += 3)
            {
                var i1 = mesh.Faces[i] + 1;
                var i2 = mesh.Faces[i + 1] + 1;
                var i3 = mesh.Faces[i + 2] + 1;
                content.AppendLine($"f {i1}/{i1}/{i1} {i2}/{i2}/{i2} {i3}/{i3}/{i3}");
            }

            await File.WriteAllTextAsync(filePath, content.ToString());

            // Create material file
            await CreateMaterialFileAsync(Path.ChangeExtension(filePath, ".mtl"));
        }

        /// <summary>
        /// Export scan metadata to JSON format
        /// </summary>
        public async Task ExportMetadataToJsonAsync(Dictionary<string, object> metadata, string filePath)
        {
            var json = System.Text.Json.JsonSerializer.Serialize(metadata, new System.Text.Json.JsonSerializerOptions
            {
                WriteIndented = true
            });

            await File.WriteAllTextAsync(filePath, json);
        }

        /// <summary>
        /// Export point cloud in ASCII PLY format
        /// </summary>
        private async Task ExportPlyAsciiAsync(ColoredPoint3D[] points, string filePath, string header)
        {
            using var writer = new StreamWriter(filePath);
            await writer.WriteAsync(header);

            foreach (var point in points)
            {
                var r = (byte)(point.Color.X * 255);
                var g = (byte)(point.Color.Y * 255);
                var b = (byte)(point.Color.Z * 255);

                var line = $"{point.Position.X:F6} {point.Position.Y:F6} {point.Position.Z:F6} {r} {g} {b}";
                
                if (point.Normal != default)
                {
                    line += $" {point.Normal.X:F6} {point.Normal.Y:F6} {point.Normal.Z:F6}";
                }
                
                await writer.WriteLineAsync(line);
            }
        }

        /// <summary>
        /// Export point cloud in binary PLY format
        /// </summary>
        private async Task ExportPlyBinaryAsync(ColoredPoint3D[] points, string filePath, string header)
        {
            using var fileStream = new FileStream(filePath, FileMode.Create);
            using var writer = new StreamWriter(fileStream);
            
            // Write ASCII header
            await writer.WriteAsync(header);
            await writer.FlushAsync();

            // Write binary data
            using var binaryWriter = new BinaryWriter(fileStream);
            
            foreach (var point in points)
            {
                // Position (3 floats)
                binaryWriter.Write(point.Position.X);
                binaryWriter.Write(point.Position.Y);
                binaryWriter.Write(point.Position.Z);

                // Color (3 bytes)
                binaryWriter.Write((byte)(point.Color.X * 255));
                binaryWriter.Write((byte)(point.Color.Y * 255));
                binaryWriter.Write((byte)(point.Color.Z * 255));

                // Normal (3 floats, if present)
                if (point.Normal != default)
                {
                    binaryWriter.Write(point.Normal.X);
                    binaryWriter.Write(point.Normal.Y);
                    binaryWriter.Write(point.Normal.Z);
                }
            }
        }

        /// <summary>
        /// Export mesh in ASCII STL format
        /// </summary>
        private async Task ExportStlAsciiAsync(Mesh mesh, string filePath)
        {
            var content = new StringBuilder();
            content.AppendLine($"solid {Path.GetFileNameWithoutExtension(filePath)}");

            for (int i = 0; i < mesh.Faces.Length; i += 3)
            {
                var v1 = mesh.Vertices[mesh.Faces[i]];
                var v2 = mesh.Vertices[mesh.Faces[i + 1]];
                var v3 = mesh.Vertices[mesh.Faces[i + 2]];

                // Calculate face normal
                var edge1 = v2.Position - v1.Position;
                var edge2 = v3.Position - v1.Position;
                var normal = System.Numerics.Vector3.Normalize(System.Numerics.Vector3.Cross(edge1, edge2));

                content.AppendLine($"  facet normal {normal.X:E} {normal.Y:E} {normal.Z:E}");
                content.AppendLine("    outer loop");
                content.AppendLine($"      vertex {v1.Position.X:E} {v1.Position.Y:E} {v1.Position.Z:E}");
                content.AppendLine($"      vertex {v2.Position.X:E} {v2.Position.Y:E} {v2.Position.Z:E}");
                content.AppendLine($"      vertex {v3.Position.X:E} {v3.Position.Y:E} {v3.Position.Z:E}");
                content.AppendLine("    endloop");
                content.AppendLine("  endfacet");
            }

            content.AppendLine($"endsolid {Path.GetFileNameWithoutExtension(filePath)}");
            await File.WriteAllTextAsync(filePath, content.ToString());
        }

        /// <summary>
        /// Export mesh in binary STL format
        /// </summary>
        private Task ExportStlBinaryAsync(Mesh mesh, string filePath)
        {
            return Task.Run(() =>
            {
                using var fileStream = new FileStream(filePath, FileMode.Create);
                using var writer = new BinaryWriter(fileStream);

                // Header (80 bytes)
                var header = new byte[80];
                var headerText = Encoding.ASCII.GetBytes($"Binary STL exported from Azure Kinect 3D Scanner");
                Array.Copy(headerText, header, Math.Min(headerText.Length, 80));
                writer.Write(header);

                // Number of triangles
                var triangleCount = mesh.Faces.Length / 3;
            writer.Write((uint)triangleCount);

            // Triangles
            for (int i = 0; i < mesh.Faces.Length; i += 3)
            {
                var v1 = mesh.Vertices[mesh.Faces[i]];
                var v2 = mesh.Vertices[mesh.Faces[i + 1]];
                var v3 = mesh.Vertices[mesh.Faces[i + 2]];

                // Calculate face normal
                var edge1 = v2.Position - v1.Position;
                var edge2 = v3.Position - v1.Position;
                var normal = System.Numerics.Vector3.Normalize(System.Numerics.Vector3.Cross(edge1, edge2));

                // Normal vector (3 floats)
                writer.Write(normal.X);
                writer.Write(normal.Y);
                writer.Write(normal.Z);

                // Vertices (9 floats)
                writer.Write(v1.Position.X);
                writer.Write(v1.Position.Y);
                writer.Write(v1.Position.Z);
                
                writer.Write(v2.Position.X);
                writer.Write(v2.Position.Y);
                writer.Write(v2.Position.Z);
                
                writer.Write(v3.Position.X);
                writer.Write(v3.Position.Y);
                writer.Write(v3.Position.Z);

                // Attribute byte count (2 bytes, usually 0)
                writer.Write((ushort)0);
            }
            });
        }

        /// <summary>
        /// Create material file for OBJ export
        /// </summary>
        private async Task CreateMaterialFileAsync(string mtlFilePath)
        {
            var content = new StringBuilder();
            content.AppendLine("# Material file generated by Azure Kinect 3D Scanner");
            content.AppendLine();
            content.AppendLine("newmtl material0");
            content.AppendLine("Ka 0.2 0.2 0.2");  // Ambient color
            content.AppendLine("Kd 0.8 0.8 0.8");  // Diffuse color
            content.AppendLine("Ks 0.5 0.5 0.5");  // Specular color
            content.AppendLine("Ns 50.0");          // Specular exponent
            content.AppendLine("d 1.0");            // Transparency

            await File.WriteAllTextAsync(mtlFilePath, content.ToString());
        }

        /// <summary>
        /// Get available export formats
        /// </summary>
        public Dictionary<string, string> GetSupportedFormats()
        {
            return new Dictionary<string, string>
            {
                { ".ply", "Stanford PLY (Polygon File Format)" },
                { ".stl", "STL (Stereolithography)" },
                { ".obj", "Wavefront OBJ" },
                { ".json", "JSON Metadata" }
            };
        }

        /// <summary>
        /// Validate export parameters
        /// </summary>
        public (bool isValid, string errorMessage) ValidateExportParameters(string filePath, string format)
        {
            if (string.IsNullOrWhiteSpace(filePath))
                return (false, "File path cannot be empty");

            if (!GetSupportedFormats().ContainsKey(format.ToLower()))
                return (false, $"Unsupported format: {format}");

            try
            {
                var directory = Path.GetDirectoryName(filePath);
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }
            }
            catch (Exception ex)
            {
                return (false, $"Cannot create directory: {ex.Message}");
            }

            return (true, string.Empty);
        }
    }
}
